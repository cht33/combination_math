# 组合数学全排列项目报告
##### 2021 陈海天 2021310754 潘俊臣
## 四种全排列算法及其改进
### 递增进制数法
- 原算法流程：
  
  维护递增进制中介数，每迭代一次，按照递增进制原则给中介数加一。

  每迭代一次，按照定义转换中介数至实际排列。从高位开始确定数字位置，当前数字i对应的位置是从低位开始数ai个空位后的下一个位置。(实现中使用了类似链表的指向性结构维护空位)

- 优化后算法：
  
  维护递增进制中介数，每迭代一次，按照递增进制原则给中介数加一。

  考虑加一的过程中，产生变化的位ak..a2，影响的数字是1-k，更大的数字对应的中介数值没有被影响。那么按照定义转换，由于更大的数字先放，所以更大的数字位置不变，那么实际上迭代一次后的排列可以由原排列修改k位后得到。具体来说，算法需要维护每一个数字所在的位置，每次中介数尾数的(k-1)位发生变化，就要修改k个位置上的数的相对顺序，其中最大的k应该被提前到原先顺位的前一个，其余的(k-1)个数应该按照从小到大排列在剩下的位置上。

  举例：(3221)↑->(3300)↑对应排列：35421->45123。观察中介数尾数有3位改变，则本次迭代影响1-4的位置，也就是5的位置不变，4向前一位替代3，剩下的三个空位给1-3按照从小到大排序。

### 递减进制数法

- 原算法流程：
  
  维护递减进制中介数，每迭代一次，按照递减进制原则给中介数加一。

  每迭代一次，按照定义转换中介数至实际排列。从高位开始确定数字位置，当前数字i对应的位置是从低位开始数ai个空位后的下一个位置。(实现中使用了类似链表的指向性结构维护空位)

- 优化后算法：
  
  维护递减进制中介数，每迭代一次，按照递减进制原则给中介数加一。

  考虑加一的过程中，产生变化的位ak..an，影响的数字是k-n，更小的数字对应的中介数值没有被影响(也就是相对位置不变)。而由于进位，所以(k+1)-n对应的中介数的值必然是从最大值归零，所以迭代前(k+1)-n这几个数必然降序排列在最高位，而迭代后必然增序排列在最低位。而对于k来说，其中介数的值增加了一，(k+1)-n的位置不影响k的相对位置，所以k只需要在1-k的子排列中向前挪动一位。

  举例：(1134)↓->(1200)↓对应排列：54231->32145。观察中介数尾数有3位改变，则本次迭代影响3-5的位置，此时处在开头的54迭代后会呈增序45排列在尾部，3则在子排列231中向前一位变为321，加上尾部的45，构成新排列32145。

### 邻位对换法
### 字典序法

- 算法流程：
  
  每次迭代，从低位开始向高位搜索，找到第一个降序点(即高位值ai小于低位值ai-1)。再从低位到高位搜索，找到第一个大于ai的值aj，交换二者。最后将降序点后的序列翻转，就得到了迭代后的序列

## 课程外全排列算法
### 基于堆的算法
### 新式递归法

- 算法流程：
  
  递归式算法中，每一层迭代算法都会从1尝试到N，并借助一个标记数组来确定之前的层有没有用过相同的元素，最终生成一个按照字典序的全排列。所以层数N*每层尝试次数N，递归式算法的复杂度是O(N^N)

  设计的新递归算法则维护一个可用集合，避免了每层探测N次(其中的很多尝试都是无用功，因为上层已经用过了)。具体来说，新算法维持一个1-N的可用元素集合，作为每次探索的候选。每层递归都会使得集合的元素减少一个，而从递归返回则会使得集合的元素增加回来。在实际的实现中，我们利用全局的数组和边界标记变量实现了这个可用元素集合。每次用掉一个元素，就将他与边界上的元素换位，并将边界左移一个元素，释放一个元素则反之。这种新设计使得每迭代一层，可选元素少一个，最终的时间复杂度就是O(N!)

## 运行效果对比
## 分工